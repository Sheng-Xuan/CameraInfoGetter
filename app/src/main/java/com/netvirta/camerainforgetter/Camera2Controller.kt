package com.netvirta.camerainforgetter

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.Camera
import android.graphics.Color
import android.graphics.ImageFormat
import android.hardware.camera2.*
import android.hardware.camera2.CameraCharacteristics.FLASH_INFO_AVAILABLE
import android.hardware.camera2.CameraCharacteristics.LENS_FACING
import android.media.Image
import android.media.ImageReader
import android.os.Build
import android.os.Handler
import android.os.HandlerThread
import android.renderscript.RenderScript
import android.util.Size
import androidx.core.content.ContextCompat
import java.nio.ByteBuffer
import java.util.concurrent.Semaphore
import java.util.concurrent.TimeUnit
import kotlin.math.roundToInt


class Camera2Controller(val context: Context) {
    val TAG = "CAMERA2"
    lateinit var cameraManager: CameraManager
    lateinit var cameraIdList: Array<String>
    lateinit var frontResolutionList: ArrayList<Size>
    lateinit var backResolutionList: ArrayList<Size>

    var backMainCharacteristics: CameraCharacteristics? = null
    var frontMainCharacteristics: CameraCharacteristics? = null

    // Resolutions
    var imageWidth: Int = 0
    var imageHeight: Int = 0
    var previewImageWidth: Int = 0
    var previewImageHeight: Int = 0

    // CameraIds
    var frontCameraId: String? = null
    var backCameraId: String? = null
    var selectedCameraId: String? = null

    // Camera attributes
    var uuid: String? = null
    var facing: Int? = CameraCharacteristics.LENS_FACING_FRONT
    var isFlashSupported = false
    var isTorchOn = false

    /**
     * A [Semaphore] to prevent the app from exiting before closing the camera.
     */
    private val cameraOpenCloseLock = Semaphore(1)

    /**
     * A reference to the opened [CameraDevice].
     */
    private var cameraDevice: CameraDevice? = null

    /**
     * A [CameraCaptureSession] for camera preview.
     */
    private var captureSession: CameraCaptureSession? = null

    /**
     * [CaptureRequest.Builder] for the camera preview
     */
    private lateinit var previewRequestBuilder: CaptureRequest.Builder

    /**
     * [CaptureRequest] generated by [.previewRequestBuilder]
     */
    private lateinit var previewRequest: CaptureRequest

    /**
     * [CameraDevice.StateCallback] is called when [CameraDevice] changes its state.
     */
    private val stateCallback = object : CameraDevice.StateCallback() {

        override fun onOpened(cameraDevice: CameraDevice) {
            cameraOpenCloseLock.release()
            this@Camera2Controller.cameraDevice = cameraDevice
        }

        override fun onDisconnected(cameraDevice: CameraDevice) {
            cameraOpenCloseLock.release()
            cameraDevice.close()
            this@Camera2Controller.cameraDevice = null
        }

        override fun onError(cameraDevice: CameraDevice, error: Int) {
            onDisconnected(cameraDevice)
            println("on Camera error $error")
        }
    }

    init {
        startBackgroundThread()
    }

    private var backgroundThread: HandlerThread? = null
    private var backgroundHandler: Handler? = null

    fun closeCamera() {
        try {
            cameraOpenCloseLock.acquire()
            captureSession?.close()
            captureSession = null
            cameraDevice?.close()
            cameraDevice = null
            stopBackgroundThread()
        } catch (e: InterruptedException) {
            throw RuntimeException("Interrupted while trying to lock camera closing.", e)
        } finally {
            cameraOpenCloseLock.release()
        }
    }

    private fun openCamera() {
        val permission = ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA)
        if (permission != PackageManager.PERMISSION_GRANTED) {
            //requestCameraPermission()
            return
        }
        try {
            if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw RuntimeException("Time out waiting to lock camera opening")
            }
        } catch (e: CameraAccessException) {
        }
    }

    fun setResolution(lowWidth: Int, lowHeight: Int, highWidth: Int, highHeight: Int) {
        this.imageHeight = highHeight
        this.imageWidth = highWidth
        this.previewImageHeight = lowHeight
        this.previewImageWidth = lowWidth
    }


    // select the first camera  based on the giving facing, in order to pass back the resolution list to engine
    fun getCameraInfo(facing: Int): CameraCharacteristics? {
        cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        var currentBestId = ""
        var largestResolution = 0
        try {
            cameraIdList = cameraManager.cameraIdList
            for (id in cameraIdList) {
                val characteristics = cameraManager.getCameraCharacteristics(id)
                if (characteristics.get(CameraCharacteristics.LENS_FACING) != facing) {
                    continue
                }
                val map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                        ?: continue
                if (!map.isOutputSupportedFor(ImageFormat.YUV_420_888)) {
                    continue
                }
                val available = characteristics.get(FLASH_INFO_AVAILABLE)
                isFlashSupported = available ?: false
                if (isFlashSupported) {
                    backCameraId = id
                    return characteristics
                } else if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
                    val largest = getLargestResolution(map.getOutputSizes(ImageFormat.YUV_420_888).toCollection(ArrayList()))
                    if (largest > largestResolution) {
                        largestResolution = largest
                        currentBestId = id
                    }
                }
            }
            if (cameraManager.getCameraCharacteristics(currentBestId).get(LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT) {
                frontCameraId = currentBestId
            }
            return cameraManager.getCameraCharacteristics(currentBestId)

        } catch (e: CameraAccessException) {
            println(e.message)
            return null
        }
    }

    fun getFocalLength(facing: Int, characteristics: CameraCharacteristics): CameraInfo {
        val focalLengthMM = characteristics.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS)
        val physicalSize = characteristics.get(CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE)
        val sensorSize = characteristics.get(CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE)
        val largestImageSize = getLargesSize(characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)!!.getOutputSizes(ImageFormat.YUV_420_888)!!.toCollection(ArrayList()))
        val pixelFocal = if (physicalSize != null) {
            (focalLengthMM?.get(0)?.div(physicalSize.width))?.times(largestImageSize.width)
        } else {
            -1f
        }
        return CameraInfo(
            facing = if (facing == CameraCharacteristics.LENS_FACING_FRONT) "FRONT" else "BACK",
            id = if (facing == CameraCharacteristics.LENS_FACING_FRONT) frontCameraId else backCameraId,
            focalLengthMM = focalLengthMM,
            physicalSize = physicalSize?.toString(),
            sensorSizePixel = sensorSize,
            largestImageSize = largestImageSize,
            focalLengthPixelCalculated = pixelFocal,
            model = Build.MANUFACTURER + " " + Build.MODEL
        )
        //(focal_lengh / physical_size_x) * image_size_x
    }

    fun getLargestResolution(list: ArrayList<Size>): Int {
        var current = 0
        for (size in list) {
            if (size.height * size.width > current) {
                current = size.height * size.width
            }
        }
        return current
    }

    fun getLargesSize(list: ArrayList<Size>): Size {
        var current = Size(0,0)
        for (size in list) {
            if (size.height * size.width > current.height * current.width) {
                current = size
            }
        }
        return current
    }

    fun initCamera() {
        if (backgroundHandler == null) {
            startBackgroundThread()
        }
    }

    fun selectCamera(uuid: String?, facing: Int) {
        this.facing = facing
        this.uuid = uuid
        selectedCameraId = if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
            frontCameraId
        } else {
            backCameraId
        }
    }

    /**
     * Starts a background thread and its [Handler].
     */
    private fun startBackgroundThread() {
        backgroundThread = HandlerThread("CameraBackground").also { it.start() }
        backgroundHandler = Handler(backgroundThread?.looper)
    }

    /**
     * Stops the background thread and its [Handler].
     */
    private fun stopBackgroundThread() {
        backgroundThread?.quitSafely()
        try {
            backgroundThread?.join()
            backgroundThread = null
            backgroundHandler = null
        } catch (e: InterruptedException) {
        }

    }

    fun switchFlash(turnOnFlash: Boolean) {
        if (turnOnFlash != isTorchOn) {
            try {
                if (facing == CameraCharacteristics.LENS_FACING_BACK) {
                    if (isFlashSupported) {
                        isTorchOn = !isTorchOn
                        previewRequestBuilder.set(CaptureRequest.FLASH_MODE, if (isTorchOn) CaptureRequest.FLASH_MODE_TORCH else CaptureRequest.FLASH_MODE_OFF)
                        captureSession?.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler)
                    }
                }
            } catch (e: CameraAccessException) {
                e.printStackTrace()
            }
        }
    }
}

data class CameraInfo (
    val facing: String?,
    val id: String?,
    val focalLengthMM: FloatArray?,
    val physicalSize: String?,
    val sensorSizePixel: Size?,
    val largestImageSize: Size?,
    val focalLengthPixelCalculated: Float?,
    val model: String?
)